

## 命名空间简介

用户命名空间实现首次实现（在 Linux2.6.23 中）

目前，Linux 实现了六种命名空间

- Mount namespaces（CLONE_NEWNS, Linux 2.4.19）
- UTS namespaces（CLONE_NEWUTS, Linux 2.6.19）
- IPC namespaces （CLONE_NEWIPC, Linux 2.6.19）
- PID namespaces （CLONE_NEWPID, Linux 2.6.24)
- Network namespaces （CLONE_NEWNET，始于 Linux 2.6.24，大部分由 Linux 2.6.29 完成）
- User namespaces （CLONE_NEWUSER, 始于 Linux 2.6.23，完成于 Linux 3.8）

每种命名空间的目的是将特定的全局系统资源包装在一个抽象中，使命名空间中的进程认为它们拥有全局资源的独立实例

命名空间的目标之一是支持容器的实现，容器是一种用于轻量级虚拟化（以及其他目的）的工具，它为一组进程提供了一种错觉，即它们是系统上唯一的进程

## 命名空间种类及简介

### Mount namespaces

隔离一组被进程看到的文件系统挂载点

因此，不同挂载命名空间中的进程可具有不同的文件系统层次结构视图

随着挂载命名空间的添加，`mount()`和 `umount()` 系统调用不再对系统上所有进程可见的全局挂载点集的进行操作，而仅操作与调用进程相关的挂载命名空间

挂载命名空间的用途之一是创建类似于 chroot 的限制环境，然而，与使用 chroot（）系统调用相比，挂载命名空间更安全、灵活

挂载命名空间还可用于更复杂的用途，例如：可以在主从关系中单独设置一个挂载命名空间，以便挂载事件自动从一个命名空间传播到另一个命名空间；例如：允许挂载在一个命名空间中的光盘设备自动出现在其它命名空间中

### UTS namespaces

隔离两种系统标识符（由 `uname()` 返回，使用 `sethostname()`和 `setdomainname()` 设置）：

- 主机名

- NIS 域名

在容器的上下文中，UTS 命名空间允许每个容器有自己的主机名和 NIS 域名，这有助于基于这些名称进行初始化操作和配置脚本

术语“UTS”来源于传递给 `uname()` 的结构体的名称：`struct utsname`，该结构体的名称来源于“UNIX 时分系统”

### IPC namespaces

隔离特定的进程间通信（IPC）资源，即 System V IPC 对象和POSIX 消息队列

这些 IPC 机制的共同特点是 IPC 对象并不通过文件路径名标识，每个 IPC 命名空间都有自己的 System V IPC 标识符集和 POSIX 消息队列文件系统

### PID namespaces

隔离进程的 ID 空间

换句话说，不同 PID 命名空间中的进程可以具有相同的 PID

PID 命名空间的主要好处之一是，可以在主机之间迁移容器，同时保持容器内进程的进程 ID 不变

PID 命名空间还允许每个容器有自己的 init（PID 1），它是“所有进程的祖先”，管理各种系统初始化任务，并在孤儿进程终止时获取它们

站在每个 PID 命名空间实例的角度来看，进程有两个 PID：

- 命名空间内的 PID 
- 主机系统上命名空间外的 PID

PID 命名空间可以嵌套：一个进程可从其所在的 PID 命名空间开始，一直到根 PID 命名空间，每层命名空间都有一个 PID

一个进程只能看到（例如，通过 `/proc/pid` 查看并使用 `kill()` 发送信号）它自己的 PID 命名空间中包含的进程以及该 PID 命名空间下面嵌套的命名空间

### Network namespaces 

隔离网络相关的系统资源

因此，每个网络命名空间都有自己的网络设备、IP 地址、IP 路由表、`/proc/net` 目录、端口号等

从网络的角度，网络命名空间使得容器很有用：每个容器可以有自己的（虚拟）网络设备和绑定到命名空间中的端口号的应用程序；主机系统中的路由规则可以将网络数据包定向到与特定容器关联的网络设备；因此，例如，可以在同一主机系统上有多个容器化的 web 服务器，每个服务器可绑定到其（每个容器）网络命名空间中的端口 80

### User namespaces

隔离用户和组 ID

换句话说，进程的用户和组 ID 在用户命名空间内外可以不同

一个进程可以在用户命名空间外有一个普通的无特权用户 ID，同时在命名空间内有一个值为 0 的用户 ID，这意味着进程对用户命名空间内的操作具有完全的 root 权限，但对命名空间外的操作没有权限

## API

## /proc 目录

每个进程都有一个 `/proc/[pid]/ns` 的目录，里面保存了该进程所在对应 namespace 的链接：

``` bash
> ls -l /proc/$$/ns/

lrwxrwxrwx 1 root root 0 Mar 10 11:13 cgroup -> 'cgroup:[4026531835]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 ipc -> 'ipc:[4026531839]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 mnt -> 'mnt:[4026531841]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 net -> 'net:[4026531840]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 pid -> 'pid:[4026531836]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 pid_for_children -> 'pid:[4026531836]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 time -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 time_for_children -> 'time:[4026531834]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 user -> 'user:[4026531837]'
lrwxrwxrwx 1 root root 0 Mar 10 11:13 uts -> 'uts:[4026531838]'
```

每个文件都是对应 namespace 的文件描述符，方括号里面的值是 namespace 的 inode

如果两个进程所在的 namespace 一样，那么它们列出来的 inode 是一样的；反之亦然

如果某个 namespace 中没有进程了，它会被自动删除，不需要手动删除；但是有个例外，如果 namespace 对应的文件某个应用程序打开，那么该 namespace 是不会被删除的，这个特性可以让我们保持住某个 namespace，以便后面往里面添加进程

需要注意的是，上面列出来是正常运行的 `bash` 程序的 namespace，并没有运行任何的容器，也没有执行任何和 namespace 有关的操作。也就是说，所有的程序都会有 namespace，可以简单理解成 namespace 其实就是进程的属性，然后操作系统把这个属性相同的进程组织到一起，起到资源隔离的作用

## 参考资料

- <https://cloud.tencent.com/developer/column/4124>

- 挂载传播和不可绑定挂载<https://cloud.tencent.com/developer/article/1532014>

- <https://cizixs.com/2017/08/29/linux-namespace/>