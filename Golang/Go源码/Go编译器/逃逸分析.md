## 逃逸分析简介

逃逸分析是 `Go` 语言中重要的优化阶段，用于标识变量内存应该被分配在栈区还是堆区。

在传统的 `C` 或 `C++` 语言中，开发者经常会犯的错误是函数返回了一个栈上的对象指针，在函数执行完成，栈被销毁后，继续访问被销毁栈上的对象指针，导致出现问题。

`Go` 语言能够通过编译时的逃逸分析识别这种问题：

- 自动将该变量放置到堆区，并借助 `Go` 运行时的垃圾回收机制自动释放内存
- 编译器会尽可能地将变量放置到栈中，因为栈中的对象随着函数调用结束会被自动销毁，减轻运行时分配和垃圾回收的负担

## 分配原则

在 `Go` 语言中，开发者模糊了栈区与堆区的差别，不管是字符串、数组字面量，还是通过 `new`、`make` 标识符创建的对象，都既可能被分配到栈中，也可能被分配到堆中

分配时，遵循以下两个原则：

- 原则 1：指向栈上对象的指针不能被存储到堆中
- 原则 2：指向栈上对象的指针不能超过该栈对象的生命周期

例如：

```go
package main

// 全局变量
var a *int

func main() {
	// 局部变量
	b := 1
	// 引用变量b地址
	a = &b
}

```

运行测试：

```bash
go build -gcflags '-m=2' main.go
```

得到输出：

```plain
# command-line-arguments
./main.go:6:6: can inline main with cost 9 as: func() { b := 1; a = &b }
./main.go:8:2: b escapes to heap:
./main.go:8:2:   flow: {heap} = &b:
./main.go:8:2:     from &b (address-of) at ./main.go:10:6
./main.go:8:2:     from a = &b (assign) at ./main.go:10:4
./main.go:8:2: moved to heap: b

```

在上例中：

- 变量 `a` 为全局变量，是一个指针
- 在函数中，全局变量 `a` 引用了局部变量 `b` 的地址
- 如果变量 `b` 被分配到栈中，那么最终程序将违背原则 2，因此变量 `b` 最终将被分配到堆中